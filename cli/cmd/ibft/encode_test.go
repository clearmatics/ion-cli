package ibft

import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"gotest.tools/assert"
	"math/big"
	"testing"
)

var testBlock = types.Header{
	ParentHash:  common.HexToHash("0x6893c6fe9270461992e748db2f30aa1359babbd74d0392eb4c3476ef942eb5ec"),
	UncleHash:   common.HexToHash("0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"),
	Coinbase:    common.HexToAddress("0x955425273ef777d6430d910f9a8b10adbe95fff6"),
	Root:        common.HexToHash("0x4e64a3b5ab9c561f72836209e376d035a0aa23a1fc7251e5d21c3c8437fef58e"),
	TxHash:      common.HexToHash("0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"),
	ReceiptHash: common.HexToHash("0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"),
	Bloom:       types.BytesToBloom(common.FromHex("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")),
	Difficulty:  big.NewInt(1),
	Number:      big.NewInt(38),
	GasLimit:    4877543,
	GasUsed:     0,
	Time:        1549897775,
	Extra:       common.FromHex("0xdc83010000886175746f6e69747988676f312e31302e34856c696e7578000000f90164f854944335d75841d8b85187cf651ed130774143927c799461d7d88dbc76259fcf1f26bc0b5763aebd67aead94955425273ef777d6430d910f9a8b10adbe95fff694f00d3c728929e42000c8d92d1a7e6a666f12e6edb8410c11022a97fcb2248a2d757a845b4804755702125f8b7ec6c06503ae0277ad996dc22f81431e8036b6cf9ef7d3c1ff1b65a255c9cb70dd2f4925951503a6fdbf01f8c9b8412d3849c86c8ba3ed9a79cdd71b1684364c4c4efb1f01e83ca8cf663f3c95f7ac64b711cd297527d42fb3111b8f78d5227182f38ccc442be5ac4dcb52efede89a01b84135de3661d0191247c7f835c8eb6d7939052c0da8ae234baf8bd208c00225e706112df9bad5bf773120ba4bbc55f6d18e478de43712c0cd3de7a3e2bfd65abb7c01b841735f482a051e6ad7fb76a815907e68d903b73eff4e472006e56fdeca8155cb575f4c1d3e98cf3a4b013331c1bd171d0d500243ac0e073a5fd382294c4fe996f000"),
	MixDigest:   common.HexToHash("0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365"),
	Nonce:       types.EncodeNonce(0x0000000000000000),
}

var expectedEncodedProposalBlock = common.FromHex("0xf9026fa06893c6fe9270461992e748db2f30aa1359babbd74d0392eb4c3476ef942eb5eca01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d4934794955425273ef777d6430d910f9a8b10adbe95fff6a04e64a3b5ab9c561f72836209e376d035a0aa23a1fc7251e5d21c3c8437fef58ea056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421a056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421b90100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000126834a6ce780845c61902fb87adc83010000886175746f6e69747988676f312e31302e34856c696e7578000000f858f854944335d75841d8b85187cf651ed130774143927c799461d7d88dbc76259fcf1f26bc0b5763aebd67aead94955425273ef777d6430d910f9a8b10adbe95fff694f00d3c728929e42000c8d92d1a7e6a666f12e6ed80c0a063746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365880000000000000000")

var testBlockHash = common.FromHex("0xed607d816f792bff503fc01bf8903b50aae5bbc6d00293350e38bba92cde40ab")

func Test_EncodeProposalBlock(t *testing.T) {
	proposalBlock, err := encodeProposalBlock(&testBlock)
	assert.NilError(t, err)

	assert.DeepEqual(t, proposalBlock, expectedEncodedProposalBlock)
	hash := crypto.Keccak256(proposalBlock)

	t.Error(common.ToHex(hash))

	istanbulExtra, err := ExtractIstanbulExtra(&testBlock)
	assert.NilError(t, err)

	signer, err := ecrecover(proposalBlock, istanbulExtra.Seal)
	assert.NilError(t, err)

	t.Error(signer.String())
}

func ecrecover(proposalBlock []byte, seal []byte) (common.Address, error) {
	addr, err := GetSignatureAddress(proposalBlock, seal)
	if err != nil {
		return addr, err
	}
	return addr, nil
}

func GetSignatureAddress(data []byte, sig []byte) (common.Address, error) {
	// 1. Keccak data
	hashData := crypto.Keccak256(data)
	// 2. Recover public key
	pubkey, err := crypto.SigToPub(hashData, sig)
	if err != nil {
		return common.Address{}, err
	}
	return crypto.PubkeyToAddress(*pubkey), nil
}
